<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>servlet 笔记part1</title>
    <style type="text/css">
        body {
            background-color: #2e2f2a;
            color: white;
            font-family: monospace, Microsoft YaHei UI Light, "Courier New";
            font-size: 20px;
        }

        p {
            font-size: 20px;
        }

        h1 {
            color: pink;
        }

        h2 {
            color: yellowgreen;
        }

        div {
            border: 1px solid white;
            font-size: 20px;
        }
    </style>
</head>
<body>
<h1>1. Servlet</h1>
<h2>1） 什么是Servlet?</h2>
<hr/>
<p>
    1.狭义上它是实现了servlet接口的java类<br/>
    2.Servlet是运行在Web服务器上的代码片段(组件),用户处理http请求,是SUN公司定义的javaEE规范
</p>
<h2>2) 为什么要是用servlet?</h2>
<hr/>
<p>
    可以简化Web服务端的开发,将复杂的网络通信细节(网络协议)封装到webService中,开发者仅需要提供servlet代码就可以完成Web服务端的开发
</p>

<h1>2. 如何写一个servlet</h1>
<h2>1) 安装一个web服务器(前提)</h2>
<hr/>
<h2>2) 如何写一个servlet,并部署到Tomcat上</h2>
<hr/>
<p>
    1. 创建一个java类,并让其实现servlet接口.<br/>
<div>
    注:<br/>
    1.1 该接口中一共提供了5个抽象方法<br/>
    1.2 当前只需要使用service(ServletRequest,ServletResponse)<br/>
    1.3 向response对象中添加响应信息：Helle World <br/>
</div>
2. 在web.xml中配置该java类,让webservice能够找到对应的servlet.<br/>
<div style="color:#faff51">
    &lt;web-app&gt;<br/>
    &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;<br/>
    &lt;servlet&gt;<br/>
    &lt;servlet-name&gt;RidenServlet&lt;/servlet-name&gt;<br/>
    &lt;servlet-class&gt;com.riden.tomtest.RidenServlet&lt;/servlet-class&gt;<br/>
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;<br/>
    &lt;/servlet&gt;<br/>
    &lt;servlet-mapping&gt;<br/>
    &lt;servlet-name&gt;RidenServlet&lt;/servlet-name&gt;<br/>
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;<br/>
    &lt;/servlet-mapping&gt;<br/>
    &lt;/web-app&gt;<br/>
</div>
<img src="image/pic02.png" style="width: 50%;"/><br/>
3. 将项目部署到tomcat上,并运行tomcat.
<h1>3. 实现Servlet类的另一种方案</h1>
<p>声明一个类，继承HttpServlet</p>
<h2>1) 为什么可以继承HttpServlet</h2>
<hr/>
<p>
    1. HttpServlet是Sun公司提供的Servlet接口的一个实现类<br/>
    2. HttpServlet实现了Servlet接口中所有的抽象方法<br/>
    3. 开发者仅需要继承该类，重写所需使用的方法即可<br/>
</p>
<h1>4. servlet的执行流程</h1>
<img src="image/pic03.png" style="width: 50%"><br/>
<p>
    1. 浏览器根据url的域名+端口号和服务器建立连接<br/>
    2. 浏览器生成请求数据包，并发送请求数据包<br/>
    3. 服务器收到请求数据包，解析请求数据包，创建request和response对象<br/>
    4. 服务器将请求数据存入request对象中<br/>
    5. 服务器调用Servlet的service()，将request和response传入<br/>
    6. Servlet的service()从request中获取请求数据，将生成的响应数据写入response中<br/>
    7. 服务器从response中读取响应数据，生成响应数据包，发送给浏览器<br/>
    8. 浏览器解析响应数据包，在页面上显示响应内容<br/>
</p>
<h1>5. Web服务器和Web容器的关系</h1>
<h2>1) Web服务器:</h2>
<hr/>
<p>指可以接受用户请求,为用户提供响应的程序</p>
<h2>2) Web容器</h2>
<hr/>
<p>可以为servlet提供运行环境支撑的程序<br/>
    tomcat既是Web服务器也是Web容器
</p>
<h1>6. 在servlet中获取请求参数</h1>
<h2>为什么在servlet中获取?</h2>
<hr/>
<p>由Web服务器负责从请求数据包中解析请求数据，封装好发送给Servlet，开发者在Servlet仅需要调用API，就可以获取数据</p>
<h2>如何获取?</h2>
<hr/>
<p>1. 通过request对象获取<br/>
    2. request对象提供了一个API: String value = request.getParameter(String name);<br/>
    <img src="image/pic04.png" width="50%"/>
</p>
<h1>7. Servlet获取请求参数的中文乱码问题</h1>
<p>用户提交表单到服务器,servlet接收到底是乱码</p>
<h2>1) 为什么产生乱码</h2>
<hr/>
<p>
    1. 浏览器对表单内容编码时,所使用的编码规则是html头标签中charset属性是一致的,当前是UTF-8<br/>
    2. tomcat对请求参数进行解码是默认使用的是ISO8859-1<br/>
    3. 编码规则和解码规则不一致导致乱码问题
</p><br/>
<img src="image/pic05.png" width="941"/>
<h2>2) 如何解决乱码</h2>
<hr/>
<p>可以使用request API来解决乱码</p>
<div>
    request.setCharacterEncoding("UTF-8");<br/>
    注:<br/>
    1. 该方法必须在调用getParameter()方法之前调用才生效<br/>
    2. 该方法只对post请求有效,因为该方法只能作用于保留在请求实体中的数据,而get请求实在请求行的,所以API是无效的
</div>
<p>对于get请求,tomcat提供了另一种方案</p>
<div>
    在Tomcat的配置文件夹中添加一个配置 URIEncoding="UTF-8"<br/>
    文件位置: Tomcat/conf/server.xml<br/>
    对应标签:&lt;Connector URIEncoding="UTF-8" connectionTimeout="20000" port="8080" protocol="HTTP/1.1"
    redirectPort="8443"/&gt;<br/>
    以上操作仅适用于Tomcat7版本，Tomcat8在升级时已经解决了该问题<br/>
</div>
<p>还有一种手动编码</p>
<img src="image/pic06.png" width="918"/>
<h1>8. HTTP协议的请求方式</h1>
<p>http将请求方式分为8种,其中最常用的用get和post</p>
<h2>1）为什么要分成多种请求方式？</h2>
<hr/>
<p>不同的请求方式所适用的场景及特点不同的，有针对性的使用可以提高请求的效率</p>
<h2>2) get请求</h2>
<hr/>
<p>
    1. get请求代表客户端向服务端获取数据<br/>
    2. 特点:<br/>
    请求参数直接拼接在url后面<br/>
    3. 什么情况下会用到get请求:
<div>
    1. 是浏览器地址栏的默认请求方式<br/>
    2. 是form表单默认的请求方式<br/>
    3. 点击超链接时的请求方式
</div>
<h2>3) post请求</h2>
<hr/>
<p>1. post请求表示浏览器像服务端发送数据<br/>
    2. 特点:<br/>
<div>
    post请求把数据放在请求正文中,浏览器地址栏不会显示,相对安全<br/>
    post请求可以传输的数据内容大小没有限制<br/>
    注:post请求不会对要传输的数据进行加密,如果需要解密因使用https
</div>
</p>
<h2>4) get请求和post请求的区别</h2>
<hr/>
<p>
    1. get请求表示向服务端获取数据,post请求表示向服务端提交数据<br/>
    2. get请求直接将请求参数拼接在url后,显示在浏览器地址栏,不安全,而且长度有限制<br/>
    3. post请求将请求数据放在请求正文中,不会显示在浏览器地址栏,相对get安全,而且数据大小没有限制.<br/>
</p>

<h1>9. servlet输出中文乱码的问题</h1>
<h2>1. 为什么出现乱码?</h2>
<hr/>
<img src="image/pic07.png" width="902"/>
<hr>
2. 解决响应乱码</hr>
<hr/>
<div>
    1.通知tomcat使用utf-8对响应内容进行编码<br/>
    response.setCharacterEncoding("utf-8"); 注:该注解必须在response.getWriter().writer();之前调用<br/><br/>
    2. 通知浏览器使用utf-8对响应内容进行解码<br/>
    response.setContentType("text/html;charset=utf-8");<br/><br/>
    1. setContentType使通知浏览本次响应的内容类型<br/>
    2. text/html表示本次响应的时html格式<br/>
    3. charset=utf-8,通知浏览器使用utf-8对文件进行解码(注该API有两个功能)<br/>
    3.1 通知浏览器使用utf-8对响应内容进行编码<br/>
    3.2 tomcat读取到该配置后,会自动使用utf-8对响应内容进行编码
</div>

<h1>10. 重定向</h1>
<h2>什么是重定向</h2>
<hr/>
<p>重定向是服务端在一次响应是通知浏览器访问指定的url</p>
<h2>什么时候用</h2>
<hr/>
<p>
    业务需要,比如访问前,必须先登录<br/>
</p>
<h2>如何实现重定向</h2>
<hr/>
<p>原理:302响应状态码,和location的响应头</p>
<img src="image/pic08.png" width="902"/>
<p>API:<br/>
    response.sendRedirect(String url);<br/>
</p>
<h2>重定向的特点</h2>
<hr/>
<p>
    1.<br/>
    2.<br/>
</p>

<h1>11. servlet的生命周期</h1>
<h2>什么是Servlet的生命周期</h2><br/>
<h1>servlet的生命周期就是servlet容器如何管理servlet的创建,销毁</h1>
<h2>servlet生命周期分为4个阶段</h2>
<hr/>
<p>1.实例化 2.初始化 3.就绪 4.销毁</p>
<h2>1)实例化</h2>
<hr/>
<p>
    servlet默认是当第一次servlet被访问时,才实例化对应的servlet.而且它是单例模式,创建后,多次访问任是同一个servlet<br/>
    对象但是也可以在服务启动时实例化对象,就是在web.xml文件中,&lt;servlet&gt;中添加&lt;load-on-startup&gt;标签,如果其对应的值<br/>
    大于0,那么就可以在容器启动的时候就实例化对象,而且其值越小,实例化的优先级越高
</p>
<h2>2)初始化</h2><br/>
<p>初始化在servlet实例化后执行,具体就是调用init()方法,如果必要,可以重写该方法,在其中添加逻辑</p>
<h2>3)就绪</h2><br/>
<p>初始化后就是就绪状态,每当有请求访问servlet,就会调用对应servlet的service()方法</p>
<h2>4)销毁</h2><br/>
<p>当服务器关闭时,会销毁servlet,具体就是调用destroy()方法,可以重写该方法,添加逻辑</p>

<h1>12. servlet的继承关系</h1>
<h2>1) servlet接口</h2>
<hr/>
<p>
    1. sun公司定义的接口,所有的servlet都必须直接或间接的实现该接口<br/>
    2. 该接口中有5个方法
</p>
<div><img src="image/pic09.png" width="907"/></div>
<h2>2) GenericServlet</h2>
<hr/>
<p>
    该类实现了servlet接口<br/>
    并重写了初service()以外的其他方法.
</p>
<h2>3) HttpServlet</h2>
<p>
    1. HttpServlet继承了GeniricServlet<br/>
    2. 添加了大量处理http协议的方法<br/>
    3. HttpServlet 实现了service()方法，判断用户的http请求方式，调用对应的doGet/doPost/doDelete等方法
    4. 开发者仅需要重写 doGet()或者doPost()，在其中提供处理逻辑即可
    5. 开发者也可以直接重写 service(HttpServletRequest, HttpServletResponse)，提供处理逻辑
</p>
<h1>13. ServletConfig</h1>
<h2>什么是ServletConfig?</h2>
<hr/>
<p>
    1. ServletConfig封装了web.xml中servlet的配置信息<br/>
    2. 一个servlet对应一个ServletConfig实例<br/>
    3. 一个ServletConfig只包含一个servlet的配置信息<br/>
</p>
<img src="image/pic10.png" width="1024"/>
<h2>为什么使用它?</h2>
<hr/>
<p>获取servlet的配置信息</p>
<h2>如何使用它?</h2>
<hr/>
<p>
    继承HttpServlet后,可以调用getServletConfig()方法,得到ServletConfig对象<br/>
    ServletConfig servletConfig = getServletConfig();<br/>
    String value = servletConfig.getIniParameter(name);
</p>

<h1>14. JSP</h1>
<h2>1) 什么是jsp?(java server pages)</h2>
<hr/>
<p>
    1. jsp是sun公司提出的用于动态生成响应的技术规范,用于解决servlet不适合输出html内容的问题.<br/>
    2. jsp非常向html文档,可以直接写html内容,同时还可以嵌套java代码<br/>
    3. jsp是以.jsp为后缀的文件,在第一次访问时,容器会将其转化为一个servlet
</p>
<img src="image/pic11.png" width="907"/>
<h2>2) 为什么使用jsp?</h2>
<hr/>
<p>
    可以简化web服务端的开发,开发者仅仅需要提供html内容,就可以动态生成响应内容
</p>
<img src="image/pic12.png" width="907"/>
<h2>3) 如何开发一个JSP?</h2>
<p>
    1. 创建一个以.jsp结尾的文件<br/>
    2. 在文件中添加要输出的内容 a. html的内容(css,javaScript) b. Java代码 c. JSP的指令<br/>
</p>
<h2>4) jsp中的html内容</h2>
<p>
    1. JSP中所有html的内容可以直接按照html的语法来写<br/>
    2. 所有html的内容会被当成字符串传入 out.write()方法中，内容不会变化<br/>
</p>
<h2>5) jsp中的java代码</h2>
<p>1. JSP表达式</p>
<div>
    a. 语法：&lt;%= java表达式 %&gt;<br/><br/>
    b. 所有的表达式的内容会被原样传入 out.print()方法，表达式会先被执行，然后将结果输出到页面上<br/><br/>
    c. 仅可以写表达式，不能写较长的java代码<br/>
</div>
<p>2. jsp脚本片段</p>
<div>
    a. 语法：&lt;% java代码 %&gt;<br/><br/>
    b. 脚本片段中的内容会被原样放到 service()方法中<br/><br/>
    c. 单个脚本片段中的java代码可以是不完整的，但是所有脚本片段组合在一起必须是完整的<br/>
</div>
<h2>5) jsp指令</h2>
<div>
    a. 语法：&lt;@ 指令名称 属性1=值 ... %&gt;<br/><br/>
    b. JSP的指令并不直接在页面上输出内容，它可以影响服务器将jsp翻译成.java文件的过程<br/><br/>
    c. page指令：&lt;%@ page ... %&gt;<br/>
</div>
<p>
    import 属性:<br/>
    import属性指明翻译后的类该导入哪些包
</p>

<p>
    pageEncoding 属性:<br/>
    可以解决JSP输出内容的乱码问题
</p>
<h1>15. 请求转发</h1>
<h2>什么是请求转发</h2>
<hr/>
<p>
    请求转发是在一次响应中一个web组件将一请求交给另一个web组件处理<br/>
    一般情况下是一个servlet处理数据然后交给jsp进行响应
</p>
<h2>为什么使用转发</h2>
<hr/>
<p>
    可以调用多个web组件,让不同组件发挥其优势,提高开发效率
</p>
<h2>如何实现转发</h2>
<hr/>
<p>
    1:绑定数据:<br/>
    存:request.setAttribute(String name,Object value);<br/>
    取:request.getAttribute(String name);<br/><br/>
    2:获取请求转发器:<br/>
    RequestDispatcher rd=request.getRequestDispatcher(url);<br/>
    url 是目标组件的url<br/><br/>
    3:转发请求<br/>
    rd.forward(request,response);
</p>
<h2>转发的特点</h2>
<hr/>
<p>
    1. 对浏览器是一次请求一次响应<br/>
    2. 浏览器地址栏不会发生变化<br/>
    3. 请求转发的目标是有限的,只能转发到当前项目内部的组件
</p>
<h2>重定向和转发的区别</h2>
<hr/>
<p>
    1. 请求转发：一个web组件对请求进行初步的处理，交给另一个web组件来生成响应内容<br/>
    2. 请求重定向：服务器在一次响应中通知浏览器去请求一个新的url<br/>
    3. 请求转发是一次请求一次响应，请求重定向是两次请求两次响应<br/>
    4. 请求转发的目标是有限制的，仅能转发当前web应用内部的组件；请求重定向的目标是没有限制的,既可以是当前项目内部的资源，也可以是其它的网站<br/>
    5. 请求转发可以利用request对象实现数据的共享<br/>
    6. 请求转发可以利用request对象实现数据的共享<br/>
</p>
<h1>会话状态管理</h1>
<h2>1)会话</h2>
<hr/>
<p>
    用于为了一个目的,从打开浏览器开始,到关闭浏览器未知,期间的多次请求和响应就是会话.
</p>
<h2>2)会话状态</h2>
<hr/>
<p>
    会话状态就是多次请求和响应中产生的数据
</p>
<h2>3)会话状态管理</h2>
<hr/>
<p>
    就是添加,更改,删除会话中的数据
</p>
<h2>4)为什么会有会话状态管理</h2>
<hr/>
<p>
    因为http协议是没有状态的,每一次请求都是全新的请求.
</p>
<h2>5)如何实现会话状态? </h2>
<hr/>
<p>
    Cookie: 把会话状态保存在浏览器的方式<br/>
    Session: 把会话状态保存在服务端的方式
</p>
<h1>Cookie</h1>
<h2>Cookie原理:</h2>
<hr/>
<p>
    服务端发送set-cookie响应头,向浏览器设置cookie<br/>
    浏览器发送cookie请求头,向服务端提交cookie数据
</p>
<h2>如何操作cookie:</h2>
<hr/>
<div>
    // 创建一个Cookie对象<br/>
    Cookie cookie = new Cookie(String name,String value);<br/>
    // 服务器发送cookie<br/>
    response.addCookie(cookie);<br/>
    // 服务器接收cookie
    Cookie[] cookies = request.getCookies();
</div>
<h2>cookie有效时间</h2>
<hr/>
<p>
    1:默认情况下,cookie的有效时间是在浏览器打开,到一次浏览器关闭<br/>
    2: 可以设置cookie的存活时间,一旦设置了存活时间,浏览器就会将cookie存放在本地磁盘上,直到<br/>
    达到其寿命<br/>
    cookie.setMaxAge(int second);
</p>
<h2>cookie路径问题</h2>
<hr/>
<p>
    1: Cookie在保存时有2个和路径相关的属性： 1. 域名(domain) 2. 路径(path)<br/>
    2: 浏览器发送请求时，会自动比较当前请求的url和cookie的domain+path的关系<br/>
</p>
<h3>1) 匹配规则</h3>
<div>
    <p>
        如果用户请求的url和Cookie的domain+path一致，或者是Cookie的domain+path的子路径，则在本次请求中携带该Cookie<br/><br/>
        Cookie: domain=/localhost path=/servlet07/user<br/><br/>
        domain+path= /localhost/servlet07/user<br/><br/>
        url1= /www.taobao.com 不携带 url2= /localhost/servlet05 不携带 url3= /localhost/servlet07 不携带<br/><br/>
        url4= /localhost/servlet07/user 携带 url5= /localhost/servlet07/user/test.jsp 携带<br/><br/>
    </p>
</div>
<h3>2) 设置Cookie的路径</h3>
<p>默认情况下，Cookie的路径和发送该Cookie的Servlet的父路径一致</p>
<div>
    AddCookieServlet1 /add /localhost/servlet07/add<br/>
    该Servlet的父路径是 /localhost/servlet07<br/>
    该Servlet发送的Cookie的默认路径 /localhost/servlet07<br/>
</div>
<p>可以通过API修改一个Cookie的path</p>
<div>
    cookie.setPath("url");<br/>
    request.getContextPath()->动态返回当前web应用的路径<br/><br/>
    servlet07 ->/servlet07<br/>
    servlet08 ->/servlet08<br/>
</div>
<h3>3) 删除一个Cookie</h3>
<p>
    服务器发送一个和拟删除的Cookie同name，同path的Cookie,同时设置maxAge=0，浏览器收到该Cookie后，会替换之前的Cookie,由于maxAge=0，因此直接删除该Cookie
</p>
<h3>4) 浏览器如何区别一个Cookie？</h3>
<p>
    浏览器按照一个Cookie的name+path+domain的组合来唯一标识一个Cookie
</p>
<h3>5) Cookie中的中文问题</h3>
<p>
    如果向Cookie中添加中文的value,会报500 Control character in cookie value or attribute.
</p>
<h3>5) Cookie中的中文问题</h3>
<p>
    如果向Cookie中添加中文的value,会报500 Control character in cookie value or attribute.<br/>
    1. 异常原因:根据http协议，cookie中的内容使用ASCII字符集，如果尝试向Cookie中添加中文，就会报异常。<br/>
    2. 解决方案:<br/>
    向cookie中存数据时:
</p>
<div>
    String str=URLEncoder.encode(value,"UTF-8");<br/>
    value="张飞";<br/>
    str="%E5%BC%A0%E9%A3%9E";<br/>
    Cookie c=new Cookie("name",str);<br/>
</div>
<p>向Cookie中取数据时:</p>
<div>
    String value=c.getValue();//"%E5%BC%A0%E9%A3%9E"<br/>
    String name=URLDecoder.decode(value,"UTF-8");// 张飞<br/>
</div>
<h2>Cookie的特点</h2>
<hr/>
<p>
    1. 可能被用户删除，因此不适合保存特别关键的数据<br/>
    2. Cookie保存的数据量是有限的，大约4kb<br/>
    3. 每个域名的Cookie的数量也是有限的,每个网站约50个<br/>
    4. Cookie中仅可以保存字符串<br/>
    5. Cookie可以被用户禁用<br/>
</p>

<h1>Session</h1>
<h2>什么是Session</h2>
<hr/>
<p>
    session是服务端用于保存会话状态特殊对象
</p>
<h2>Session原理</h2>
<hr/>
<p>
    1. 服务器为用户创建一个Session对象，来保存该用户的会话状态<br/>
    2. 服务器将该Session对象的sessionId，以JSESSIONID的Cookie发送给用户<br/>
    3. 用户下次请求时，会自动携带JSESSIONID的Cookie<br/>
    4. 服务器通过JSESSIONID的Cookie,找到用户对应的Session对象<br/>
</p>
<img src="image/pic13.png" width="907"/>
<h2>如何使用session</h2>
<hr/>
<div>
    <pre>
    1. HttpSession session=request.getSession(boolean);

    true: 如果用户之前有Session，直接使用该Session，
          如果用户之前没有Session，就会用户创建一个Session
          有则使用，无则创建

    false: 有则使用，无则返回null

    2. HttpSession session=request.getSession();
    等同于 request.getSession(true);
    有则使用，无则创建
    </pre>
</div>
<h2>向Session中绑定数据</h2>
<hr/>
<div>
    <pre>
1. 绑定数据
    session.setAttribute(String name,Object value);
2. 获取数据
    session.getAttribute(String name);
    </pre>
</div>
<h2>销毁session</h2>
<hr/>
<p>1. 自动销毁 服务器会自动记录一个Session的存活时间，会为Session设定一个超时时间，当用户超过这个时间都没有访问Session时，会销毁该Session</p>
<div>
    <pre>
 &lt;session-config&gt;
    &lt;!-- 配置session的超时时间，以分钟为单位，默认30分钟 --&gt;
    &lt;session-timeout&gt;15&lt;/session-timeout&gt;
  &lt;/session-config&gt;
    </pre>
</div>
<p>2. 手动销毁</p>
<div>
    session.invalidate();
</div>
<p>
    3. 钝化和活化<br/>
    钝化：当服务器正常关闭时，未超时的Session会被自动保存到服务器的硬盘上<br/>
    活化：当服务器启动时，之前硬盘上保存的Session会被读取到内存中，继续工作<br/>
</p>
<h2>session的特点</h2>
<hr/>
<p>
    1. Session的安全性和稳定性较高,因为是保存再服务器上的<br/>
    2. Session可以保存的数据理论上是没有限制的.但是不建议再session中保存大量信息,Session中的信息是保存在内存上的,如果内存不足,则保存在硬盘上.<br/>
    3. Session依赖于Cookie,如果在浏览器上禁用了Cookie,Session将失效.<br/>
    4. Session中保存数据的时间较短,一般是30分钟
</p>
<h2>Session和Request的对比</h2>
<hr/>
<img src="image/pic14.png" width="907"/>

<h1>过滤器 Filter</h1>
<h2>什么是过滤器</h2>
<hr/>
<p>
    Sun公司提供的一个Web组件,可以对请求和响应进行拦截,以执行特定的功能
</p>
<img src="image/pic15.png" width="907"/>
<h2>如何开发Filter</h2>
<hr/>
<p>
    开发一个Filter类,实现Filter接口<br/><br/>
    1) 实现Filter中所有的抽象方法<br/><br/>
    doFilter(ServletRequest,ServletResponse,FilterChain)<br/><br/>
    ServletRequest 是 HttpServletRequest的父接口，HttpServletRequest提供了一些额外的和Http协议相关的方法<br/><br/>
    ServletResponse是 HttpServletResponse的父接口，HttpServletRequest提供了一些额外的和Http协议相关的方法<br/><br/>
    FilterChain 过滤器链<br/><br/>
    调用chain.doFilter()将导致过滤器链上的下一个过滤器被调用， 或者如果当前调用的Filter是过滤器链上的最后一个Filter,将导致链尾的资源被调用<br/><br/>
</p>
<img src="image/pic16.png" width="845"/>
<p>2) 在web.xml中配置</p>
<div>
    <pre>
&lt;filter&gt;
    &lt;filter-name&gt;
    &lt;filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;
    &lt;url-pattern&gt;
&lt;/filter-mapping&gt;

url-pattern配置的是该Filter所拦截的url
如果用户请求的url与Filter的url一致，或者是它的子路径，该Fitler就会生效
一个Filter拦截多个url可使用 * 通配符，如 /user/* 拦截用户对user目录下所有资源的请求
    </pre>
</div>
<h2>3）多个Filter的生效顺序</h2>
<hr/>
<p>如果一个请求被多个Filter所拦截,这些Filter生效顺序有所配置的&lt;filter-mapping&gt;所决定的</p>
<h2>4) 过滤器的生命周期</h2>
<hr/>
<p>
    1) 实例化<br/>
    服务器启动时，加载并实例化所有在web.xml中配置的过滤器<br/><br/>
    2）初始化<br/>
    一个Filter被实例化之后，马上调用它的init()方法<br/><br/>
    3）就绪<br/>
    每当用户请求的url和当前Filter匹配时，服务器会自动调用该Filter的doFilter()，执行拦截的逻辑<br/><br/>
    4) 销毁<br/>
    当服务器关闭时，会销毁所有的Filter,在销毁一个Filter之前，会调用它的destory()方法
</p>
<h2>5）FilterConfig</h2>
<hr/>
<p>
    1. 代表了Filter在web.xml中配置的对象<br/>
    2. 服务器在调用一个Filter的init()方法时，会将创建好的FilterConfig对象作为参数，传入该方法<br/>
    3. API
</p>
<div>
    <pre>
String value=config.getInitParameter(String name);
通过参数名获取参数值

Enumeration&lt;String&gt; names=config.getInitParameterNames();
获取web.xml中为该Servlet配置的所有初始化参数的名称
    </pre>
</div>
<p>
    在web.xml中为一个Filter配置初始化参数
</p>
<div>
    <pre style="color: yellow">
&lt;filter&gt;
    &lt;display-name&gt;TimeFilter&lt;/display-name&gt;
    &lt;filter-name&gt;TimeFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;filter.TimeFilter&lt;/filter-class&gt;
    &lt;!-- 为一个Filter配置初始化参数 --&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;username&lt;/param-name&gt;
        &lt;param-value&gt;admin&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;password&lt;/param-name&gt;
        &lt;param-value&gt;123&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
    </pre>
</div>
<h1>访问路径</h1>
<h2>URL(Uniform Resource Location)</h2>
<hr/>
<p>
    统一资源定位符,用来定位互联网上的一个资源<br/>
    http://localhost:8080/servlet09/user/addUser.jsp<br/><br/>
    http:// -> 访问使用的协议<br/><br/>
    localhost -> 域名，会被自动翻译成 ip地址，找到一个服务器 :8080 -> 端口号 ， 找到服务器上的一个程序(Tomcat)<br/><br/>
    /servlet09/user/addUser.jsp是给Web服务器用的<br/><br/>
    /servlet09-> 项目的路径（ContextPath），以Tomcat为例，Tomcat会去wtpwebapps下找一个叫servlet09文件夹<br/>
</p>
<h2>常见的写路径的地方放</h2>
<hr/>
<div>
    &lt;a href="url"&gt;<br/><br/>
    &lt;img src="url"&gt;<br/><br/>
    &lt;link href="url"&gt;<br/><br/>
    &lt;script src="url"&gt;<br/><br/>
    &lt;form action="url"&gt;<br/>
</div>
<img src="image/pic17.png" width="907"/>
<h2>3) 两种路径的写法</h2><hr/>
<pre>
    相对路径:

    1. 从当前文件到目标文件所经过的路径，称为相对路径
    2. 相对路径的写法
        1.从当前目录去找 css/style.css
        2.从上级目录去找 ../css/style.css
    3. 相对路径的问题
        1.当前文件的位置一旦发生变化，路径可能失效


    绝对路径:

    1. 从一个固定的位置出发，到目标文件所经过的路径，称为绝对路径
    2. 绝对路径的写法
        1. 以/开头
        2. 相对一个固定的位置，一般是当前项目的父路径
    3. 优势
        1. 一个文件的位置即使发生变化，它也可以通过绝对路径找到另一个文件，路径不需要修改
</pre>
<h1>ServletContext</h1>
<p>
    当服务器启动后，会按顺序加载所有的web应用，每当加载完一个web应用后，会创建一个ServletContext对象，唯一代表该web应用。<br/>
    每个web应用有一个servletContext对象
</p>
<h2>用途</h2><hr/>
<h3>可以在整个web应用中共享数据</h3>
<p>
    1.所有的web组件和用户访问的都是同一个ServletContext对象<br/>
    2.如果不同的用户使用相同的name储存数据那么,数据会被覆盖<br/>
    3.不适合保存不同用户各自的数据,适合保存大家共同的数据
</p>
<h2>获取web.xml中配置的初始化参数</h2>
<div>
    <pre>
        &lt;context-param&gt;
                &lt;param-name&gt;encode&lt;/param-name&gt;
                &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/context-param&gt;

        String value=sc.getInitParameter(name);
</pre>
</div>
<h2>获取web.xml中配置的初始化参数</h2>
<div>
<p>
   String path=sc.getRealPath("");
</p>
</div>
<h2>API</h2><hr/>
<div>
    <pre>
     获取ServletContext对象

    ServeltContext sc=getServletContext();

    ServletContext sc=request.getServletContext();


    共享数据

    sc.setAttribute(String name,Object value);

    Object value=sc.getAttribute(String name);
    </pre>
</div>
<h2>概念理解</h2><hr/>
<p>
    1.Context 上下文<br/><br/>
    2.ServletContext Servlet的上下文 -> 就是Tomcat<br/><br/>
    3.ServletContext 设计了一些API，允许Servlet和Tomcat通信，获取Tomcat的一些信息
</p>

<h1>Listener (监听器)</h1>
<p>
    Sun公司提供的一类特殊的web组件，可以对一些特定的事件进行监听，执行具体的处理逻辑。<br/>
    不同的web组件对应不同的监听器
</p>

</body>
</html>